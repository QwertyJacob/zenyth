{"ast":null,"code":"import _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.math.log10.js\";\nimport * as Tone from \"tone\";\nimport { Envelope, LFO } from \"tone\";\nimport { toRaw } from \"vue\";\nvar MyFilter = /*#__PURE__*/function () {\n  function MyFilter() {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"peaking\";\n    var cutoff = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n    var resonance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n    _classCallCheck(this, MyFilter);\n    this.filter_type = type;\n    this.cutoff = cutoff;\n    this.resonance = resonance;\n    this.modulatorsData = {\n      envelope: {\n        amount: 0,\n        parameters: {\n          attack: 1,\n          decay: 0.3,\n          sustain: 0.8,\n          release: 1\n        }\n      },\n      lfo: {\n        amount: 0,\n        parameters: {\n          frequency: 10,\n          waveform: \"sine\",\n          min: 0,\n          max: 1\n        }\n      }\n    };\n\n    //to stop moduoators only when there is one left active voice and the note is released\n    this.activeNotes = 0;\n    this.modulators = {\n      envelope: {\n        signal: this.createModulator(\"envelope\"),\n        scale: new Tone.ScaleExp(0, 1, 3),\n        amount: 0\n      },\n      lfo: {\n        signal: this.createModulator(\"lfo\"),\n        scale: new Tone.ScaleExp(0, 1, 3),\n        amount: 0\n      }\n    };\n    this.filter = new Tone.Filter();\n    this.initFilterParams();\n  }\n  _createClass(MyFilter, [{\n    key: \"getCutoff\",\n    value: function getCutoff() {\n      return this.cutoff;\n    }\n  }, {\n    key: \"getResonance\",\n    value: function getResonance() {\n      return this.resonance;\n    }\n  }, {\n    key: \"createModulator\",\n    value: function createModulator(type) {\n      //console.log(\"creating modulator of type: \"+type)\n      switch (type) {\n        case \"envelope\":\n          return new Envelope();\n        case \"lfo\":\n          return new LFO();\n        default:\n          console.log(\"Error creating modulator\");\n          return null;\n      }\n    }\n\n    // ----------- AUDIO SETTERS--------------\n  }, {\n    key: \"initFilterParams\",\n    value: function initFilterParams() {\n      var self = this;\n\n      // init switched off filters\n      switch (this.filter_type) {\n        case \"lowpass\":\n          this.cutoff = .9;\n          this.resonance = 1;\n          break;\n        case \"highpass\":\n          this.cutoff = 0.1;\n          this.resonance = 1;\n          break;\n        case \"peaking\":\n          this.cutoff = 0.5;\n          this.resonance = 0.5;\n          break;\n        case \"bandpass\":\n          break;\n        case \"lowshelf\":\n          break;\n        case \"highshelf\":\n          break;\n        case \"notch\":\n          break;\n        case \"allpass\":\n          break;\n        default:\n          console.log(\"Invalid filter type\");\n      }\n      this.filter.set({\n        frequency: self.cutoffLogMapping(this.cutoff),\n        type: this.filter_type\n      });\n      this.scaleSetter(this.modulators.envelope);\n      this.scaleSetter(this.modulators.lfo);\n      this.connectModulator(this.modulators.envelope);\n      this.connectModulator(this.modulators.lfo);\n      this.updateModulators();\n    }\n\n    //------------MODULATORS LOGIC----------\n  }, {\n    key: \"scaleSetter\",\n    value: function scaleSetter(modulator) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      //console.log(modulator)\n      toRaw(modulator.scale).set({\n        min: Math.pow(10, Math.log10(this.cutoffLogMapping(this.cutoff)) - 1 * modulator.amount),\n        max: Math.pow(10, Math.log10(this.cutoffLogMapping(this.cutoff)) + 1 * modulator.amount)\n      });\n    }\n  }, {\n    key: \"connectModulator\",\n    value: function connectModulator(modulator) {\n      modulator.signal.chain(modulator.scale, this.filter.frequency);\n    }\n  }, {\n    key: \"setModulatorParameters\",\n    value: function setModulatorParameters(type, target, parameters) {\n      this.modulatorsData[type].parameters = parameters;\n      this.updateModulators();\n    }\n  }, {\n    key: \"setModulatorAmount\",\n    value: function setModulatorAmount(type, target, amount) {\n      this.modulatorsData[type].amount = amount;\n      this.updateModulators();\n    }\n  }, {\n    key: \"updateModulators\",\n    value: function updateModulators() {\n      for (var type in this.modulators) {\n        //update amount from preset\n        this.modulators[type].amount = this.modulatorsData[type].amount;\n        //reset scale\n        this.scaleSetter(this.modulators[type]);\n        //reset modulator\n        this.modulatorSetter(toRaw(this.modulators[type].signal), type, this.modulatorsData[type].parameters);\n      }\n    }\n  }, {\n    key: \"modulatorSetter\",\n    value: function modulatorSetter(modulator, type, parameters) {\n      if (!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type;\n      switch (type) {\n        case \"envelope\":\n          modulator.set({\n            \"attack\": parameters.attack,\n            \"decay\": parameters.decay,\n            \"sustain\": parameters.sustain,\n            \"release\": parameters.release + 0.001\n          });\n          break;\n        case \"lfo\":\n          modulator.set({\n            \"type\": toRaw(parameters).waveform,\n            \"frequency\": toRaw(parameters).frequency\n          });\n          break;\n        default:\n          console.log(\"Error setting modulator parameters, invalid args\");\n          break;\n      }\n    }\n  }, {\n    key: \"playNote\",\n    value: function playNote() {\n      var note = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n      //trigger attack in modulators\n      this.modulators.envelope.signal.cancel(Tone.now());\n      this.modulators.envelope.signal.triggerAttack(Tone.now());\n      this.modulators.lfo.signal.stop();\n      this.modulators.lfo.signal.start();\n      //console.log(\"PLAYED FILTER MODULATORS\")\n      this.activeNotes++;\n    }\n  }, {\n    key: \"stopNote\",\n    value: function stopNote() {\n      var note = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      if (this.activeNotes <= 1) {\n        this.modulators.envelope.signal.triggerRelease(Tone.now());\n        //lfos never stopped\n        //this.modulators.lfo.signal.stop()\n        //console.log(\"STOPPED FILTER MODULATORS\")\n      }\n\n      this.activeNotes--;\n    }\n\n    //--------------------\n  }, {\n    key: \"setCutoff\",\n    value: function setCutoff() {\n      var cutoff = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cutoff;\n      this.cutoff = cutoff;\n      var self = this;\n      this.filter.set({\n        frequency: self.cutoffLogMapping(this.cutoff)\n      });\n      /*\n      console.log(\n          this.filter_type +\n          \" cutoff: \" +\n          this.cutoff.toFixed(2) +\n          \" - \" +\n          this.cutoffLogMapping(this.cutoff).toFixed(0) +\n          \" Hz\"\n      );\n        */\n      this.updateModulators();\n    }\n  }, {\n    key: \"setResonance\",\n    value: function setResonance() {\n      var resonance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.resonance;\n      this.resonance = resonance;\n      var self = this;\n      if (this.filter_type === \"lowshelf\" || this.filter_type === \"highshelf\" || this.filter_type === \"peaking\") {\n        // bell delta amplitude is controlled changing the 'gain' parameter\n        this.filter.set({\n          gain: self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n        });\n        /*\n        console.log(\n            \"Setting Peaking Resonance: \" +\n            self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n        );\n          */\n      } else if (this.filter_type === \"lowpass\" || this.filter_type === \"highpass\") {\n        // filter's Q is controlled changing the 'Q' parameter\n        this.filter.set({\n          Q: self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n        });\n        /*\n        console.log(\n            \"Setting LowPass/HighPass Resonance: \" +\n            self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n        );\n          */\n      }\n      /*\n          console.log(\n            \"resonance: \" +\n              this.resonance.toFixed(2) +\n              \" - \" +\n              Math.round(this.resonanceRangeNormalizer((self.resonance), this.type)) +\n              \" dB\"\n          );\n      */\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      try {\n        this.filter.connect(destination);\n      } catch (err) {\n        console.log(\"ERROR: \" + err + \" - myfilter: \", this.filter, \" -connect to destination: \", destination);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(destination) {\n      if (destination) {\n        this.filter.disconnect(destination);\n      } else {\n        this.filter.disconnect(destination);\n      }\n    }\n  }, {\n    key: \"getToneFilter\",\n    value: function getToneFilter() {\n      return this.filter;\n    }\n\n    // ----------- AUDIO HELPERS--------------\n    // takes value in [0, 1] range and it maps it to [50, 16000] interval in a logarithmic fashion\n  }, {\n    key: \"cutoffLogMapping\",\n    value: function cutoffLogMapping(x) {\n      if (x < 0 || x > 1) {\n        console.error(\"Input value must be between 0 and 1.\");\n        return;\n      }\n      return 20 * Math.pow(10, Math.log10(22000 / 20) * x);\n    }\n\n    // takes value in [0, 1] range and it maps it to [0, 10] linearly\n  }, {\n    key: \"resonanceRangeNormalizer\",\n    value: function resonanceRangeNormalizer(x, type) {\n      if (x < 0 || x > 1) {\n        console.error(\"Input value must be between 0 and 1.\");\n        return;\n      }\n      switch (type) {\n        case \"lowpass\":\n          return 15 * x;\n        case \"highpass\":\n          return 15 * x;\n        case \"peaking\":\n          return 30 * (x - 0.5);\n        default:\n          break;\n      }\n    }\n  }]);\n  return MyFilter;\n}();\nexport { MyFilter as default };","map":{"version":3,"names":["Tone","Envelope","LFO","toRaw","MyFilter","type","cutoff","resonance","filter_type","modulatorsData","envelope","amount","parameters","attack","decay","sustain","release","lfo","frequency","waveform","min","max","activeNotes","modulators","signal","createModulator","scale","ScaleExp","filter","Filter","initFilterParams","console","log","self","set","cutoffLogMapping","scaleSetter","connectModulator","updateModulators","modulator","target","Math","pow","log10","chain","modulatorSetter","note","velocity","cancel","now","triggerAttack","stop","start","triggerRelease","gain","resonanceRangeNormalizer","Q","destination","connect","err","disconnect","x","error"],"sources":["/Users/eliapirrello/Documents/GitHub/zenyth/src/views/Synth/Filters/MyFilter.js"],"sourcesContent":["import * as Tone from \"tone\";\nimport {Envelope, LFO} from \"tone\";\nimport {toRaw} from \"vue\";\n\nexport default class MyFilter {\n    constructor(type = \"peaking\", cutoff = 0.5, resonance = 0.5) {\n\n        this.filter_type = type;\n        this.cutoff = cutoff;\n        this.resonance = resonance;\n\n        this.modulatorsData = {\n            envelope: {\n                amount: 0,\n                parameters: {\n                    attack: 1,\n                    decay: 0.3,\n                    sustain: 0.8,\n                    release: 1\n                }\n            },\n            lfo: {\n                amount: 0,\n                parameters: {\n                    frequency: 10,\n                    waveform: \"sine\",\n                    min: 0,\n                    max: 1\n                }\n            }\n        }\n\n        //to stop moduoators only when there is one left active voice and the note is released\n        this.activeNotes=0\n\n        this.modulators = {\n            envelope: {\n                signal: this.createModulator(\"envelope\"),\n                scale: new Tone.ScaleExp(0, 1, 3),\n                amount: 0\n            },\n            lfo: {\n                signal: this.createModulator(\"lfo\"),\n                scale: new Tone.ScaleExp(0, 1, 3),\n                amount: 0\n            }\n        }\n\n        this.filter = new Tone.Filter();\n        this.initFilterParams();\n\n\n    }\n\n    getCutoff() {\n        return this.cutoff\n    }\n\n    getResonance() {\n        return this.resonance\n    }\n\n    createModulator(type) {\n        //console.log(\"creating modulator of type: \"+type)\n        switch (type) {\n            case \"envelope\":\n                return new Envelope\n            case \"lfo\":\n                return new LFO\n            default:\n                console.log(\"Error creating modulator\")\n                return null\n        }\n    }\n\n\n    // ----------- AUDIO SETTERS--------------\n    initFilterParams() {\n        let self = this;\n\n        // init switched off filters\n        switch (this.filter_type) {\n            case \"lowpass\":\n                this.cutoff = .9;\n                this.resonance = 1;\n                break;\n            case \"highpass\":\n                this.cutoff = 0.1;\n                this.resonance = 1;\n                break;\n            case \"peaking\":\n                this.cutoff = 0.5;\n                this.resonance = 0.5;\n                break;\n            case \"bandpass\":\n                break;\n            case \"lowshelf\":\n                break;\n            case \"highshelf\":\n                break;\n            case \"notch\":\n                break;\n            case \"allpass\":\n                break;\n            default:\n                console.log(\"Invalid filter type\");\n        }\n\n        this.filter.set({\n            frequency: self.cutoffLogMapping(this.cutoff),\n            type: this.filter_type,\n        })\n\n        this.scaleSetter(this.modulators.envelope)\n        this.scaleSetter(this.modulators.lfo)\n        this.connectModulator(this.modulators.envelope)\n        this.connectModulator(this.modulators.lfo)\n        this.updateModulators()\n\n    }\n\n\n    //------------MODULATORS LOGIC----------\n\n    scaleSetter(modulator, target = \"\") {\n        //console.log(modulator)\n        toRaw(modulator.scale).set({\n\n            min: (Math.pow(10, Math.log10(this.cutoffLogMapping(this.cutoff)) - 1 * modulator.amount)),\n            max: (Math.pow(10, Math.log10(this.cutoffLogMapping(this.cutoff)) + 1 * modulator.amount)),\n        })\n\n    }\n\n    connectModulator(modulator) {\n        modulator.signal.chain(modulator.scale, this.filter.frequency)\n    }\n\n    setModulatorParameters(type, target, parameters) {\n        this.modulatorsData[type].parameters = parameters\n        this.updateModulators()\n    }\n\n    setModulatorAmount(type, target, amount) {\n        this.modulatorsData[type].amount = amount\n        this.updateModulators()\n    }\n\n    updateModulators() {\n        for (let type in this.modulators) {\n            //update amount from preset\n            this.modulators[type].amount = this.modulatorsData[type].amount\n            //reset scale\n            this.scaleSetter(this.modulators[type])\n            //reset modulator\n            this.modulatorSetter(toRaw(this.modulators[type].signal), type, this.modulatorsData[type].parameters)\n        }\n    }\n\n    modulatorSetter(modulator, type, parameters) {\n        if (!toRaw(parameters).waveform) toRaw(parameters).waveform = modulator.type\n        switch (type) {\n            case \"envelope\":\n                modulator.set({\n                    \"attack\": parameters.attack,\n                    \"decay\": parameters.decay,\n                    \"sustain\": parameters.sustain,\n                    \"release\": parameters.release + 0.001,\n                })\n                break;\n            case \"lfo\":\n                modulator.set({\n                    \"type\": toRaw(parameters).waveform,\n                    \"frequency\": toRaw(parameters).frequency\n                })\n                break;\n            default:\n                console.log(\"Error setting modulator parameters, invalid args\")\n                break;\n        }\n    }\n\n    playNote(note = \"\", velocity = \"\") {\n        //trigger attack in modulators\n        this.modulators.envelope.signal.cancel(Tone.now())\n        this.modulators.envelope.signal.triggerAttack(Tone.now())\n        this.modulators.lfo.signal.stop()\n        this.modulators.lfo.signal.start()\n        //console.log(\"PLAYED FILTER MODULATORS\")\n        this.activeNotes++\n    }\n    stopNote(note=\"\") {\n        if(this.activeNotes<=1){\n            this.modulators.envelope.signal.triggerRelease(Tone.now())\n            //lfos never stopped\n            //this.modulators.lfo.signal.stop()\n            //console.log(\"STOPPED FILTER MODULATORS\")\n        }\n        this.activeNotes--\n    }\n\n\n    //--------------------\n\n\n    setCutoff(cutoff = this.cutoff) {\n        this.cutoff = cutoff;\n        let self = this;\n        this.filter.set({\n            frequency: self.cutoffLogMapping(this.cutoff),\n        });\n        /*\n        console.log(\n            this.filter_type +\n            \" cutoff: \" +\n            this.cutoff.toFixed(2) +\n            \" - \" +\n            this.cutoffLogMapping(this.cutoff).toFixed(0) +\n            \" Hz\"\n        );\n\n         */\n        this.updateModulators()\n    }\n\n    setResonance(resonance = this.resonance) {\n        this.resonance = resonance;\n        let self = this;\n\n        if (this.filter_type === \"lowshelf\" || this.filter_type === \"highshelf\" || this.filter_type === \"peaking\") {\n            // bell delta amplitude is controlled changing the 'gain' parameter\n            this.filter.set({\n                gain: self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type),\n            });\n            /*\n            console.log(\n                \"Setting Peaking Resonance: \" +\n                self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n            );\n\n             */\n        } else if (this.filter_type === \"lowpass\" || this.filter_type === \"highpass\") {\n            // filter's Q is controlled changing the 'Q' parameter\n            this.filter.set({\n                Q: self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type),\n            });\n            /*\n            console.log(\n                \"Setting LowPass/HighPass Resonance: \" +\n                self.resonanceRangeNormalizer(1 - self.resonance, this.filter_type)\n            );\n\n             */\n        }\n        /*\n            console.log(\n              \"resonance: \" +\n                this.resonance.toFixed(2) +\n                \" - \" +\n                Math.round(this.resonanceRangeNormalizer((self.resonance), this.type)) +\n                \" dB\"\n            );\n        */\n    }\n\n    connect(destination) {\n        try {\n            this.filter.connect(destination);\n        } catch (err) {\n            console.log(\"ERROR: \" + err + \" - myfilter: \", this.filter, \" -connect to destination: \", destination);\n        }\n    }\n\n    disconnect(destination) {\n        if (destination) {\n            this.filter.disconnect(destination)\n        } else {\n            this.filter.disconnect(destination)\n        }\n    }\n\n    getToneFilter() {\n        return this.filter;\n    }\n\n    // ----------- AUDIO HELPERS--------------\n    // takes value in [0, 1] range and it maps it to [50, 16000] interval in a logarithmic fashion\n    cutoffLogMapping(x) {\n        if (x < 0 || x > 1) {\n            console.error(\"Input value must be between 0 and 1.\");\n            return;\n        }\n        return 20 * Math.pow(10, Math.log10(22000 / 20) * x);\n    }\n\n    // takes value in [0, 1] range and it maps it to [0, 10] linearly\n    resonanceRangeNormalizer(x, type) {\n        if (x < 0 || x > 1) {\n            console.error(\"Input value must be between 0 and 1.\");\n            return;\n        }\n        switch (type) {\n            case \"lowpass\":\n                return 15 * x;\n            case \"highpass\":\n                return 15 * x;\n            case \"peaking\":\n                return 30 * (x - 0.5);\n            default:\n                break;\n        }\n    }\n\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}