{"ast":null,"code":"import _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array-buffer.slice.js\";\nimport \"core-js/modules/es.typed-array.float32-array.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.copy-within.js\";\nimport \"core-js/modules/es.typed-array.every.js\";\nimport \"core-js/modules/es.typed-array.fill.js\";\nimport \"core-js/modules/es.typed-array.filter.js\";\nimport \"core-js/modules/es.typed-array.find.js\";\nimport \"core-js/modules/es.typed-array.find-index.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.typed-array.for-each.js\";\nimport \"core-js/modules/es.typed-array.includes.js\";\nimport \"core-js/modules/es.typed-array.index-of.js\";\nimport \"core-js/modules/es.typed-array.iterator.js\";\nimport \"core-js/modules/es.typed-array.join.js\";\nimport \"core-js/modules/es.typed-array.last-index-of.js\";\nimport \"core-js/modules/es.typed-array.map.js\";\nimport \"core-js/modules/es.typed-array.reduce.js\";\nimport \"core-js/modules/es.typed-array.reduce-right.js\";\nimport \"core-js/modules/es.typed-array.reverse.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.typed-array.slice.js\";\nimport \"core-js/modules/es.typed-array.some.js\";\nimport \"core-js/modules/es.typed-array.sort.js\";\nimport \"core-js/modules/es.typed-array.subarray.js\";\nimport \"core-js/modules/es.typed-array.to-locale-string.js\";\nimport \"core-js/modules/es.typed-array.to-string.js\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport var Analyser = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Analyser, _ToneAudioNode);\n  var _super = _createSuper(Analyser);\n  function Analyser() {\n    var _this;\n    _classCallCheck(this, Analyser);\n    _this = _super.call(this, optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n    _this.name = \"Analyser\";\n    /**\n     * The analyser node.\n     */\n    _this._analysers = [];\n    /**\n     * The buffer that the FFT data is written to\n     */\n    _this._buffers = [];\n    var options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n    _this.input = _this.output = _this._gain = new Gain({\n      context: _this.context\n    });\n    _this._split = new Split({\n      context: _this.context,\n      channels: options.channels\n    });\n    _this.input.connect(_this._split);\n    assertRange(options.channels, 1);\n    // create the analysers\n    for (var channel = 0; channel < options.channels; channel++) {\n      _this._analysers[channel] = _this.context.createAnalyser();\n      _this._split.connect(_this._analysers[channel], channel, 0);\n    }\n    // set the values initially\n    _this.size = options.size;\n    _this.type = options.type;\n    return _this;\n  }\n  _createClass(Analyser, [{\n    key: \"getValue\",\n    value:\n    /**\n     * Run the analysis given the current settings. If [[channels]] = 1,\n     * it will return a Float32Array. If [[channels]] > 1, it will\n     * return an array of Float32Arrays where each index in the array\n     * represents the analysis done on a channel.\n     */\n    function getValue() {\n      var _this2 = this;\n      this._analysers.forEach(function (analyser, index) {\n        var buffer = _this2._buffers[index];\n        if (_this2._type === \"fft\") {\n          analyser.getFloatFrequencyData(buffer);\n        } else if (_this2._type === \"waveform\") {\n          analyser.getFloatTimeDomainData(buffer);\n        }\n      });\n      if (this.channels === 1) {\n        return this._buffers[0];\n      } else {\n        return this._buffers;\n      }\n    }\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._analysers[0].frequencyBinCount;\n    },\n    set: function set(size) {\n      var _this3 = this;\n      this._analysers.forEach(function (analyser, index) {\n        analyser.fftSize = size * 2;\n        _this3._buffers[index] = new Float32Array(size);\n      });\n    }\n    /**\n     * The number of channels the analyser does the analysis on. Channel\n     * separation is done using [[Split]]\n     */\n  }, {\n    key: \"channels\",\n    get: function get() {\n      return this._analysers.length;\n    }\n    /**\n     * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      assert(type === \"waveform\" || type === \"fft\", \"Analyser: invalid type: \".concat(type));\n      this._type = type;\n    }\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n  }, {\n    key: \"smoothing\",\n    get: function get() {\n      return this._analysers[0].smoothingTimeConstant;\n    },\n    set: function set(val) {\n      this._analysers.forEach(function (a) {\n        return a.smoothingTimeConstant = val;\n      });\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Analyser.prototype), \"dispose\", this).call(this);\n      this._analysers.forEach(function (a) {\n        return a.disconnect();\n      });\n      this._split.dispose();\n      this._gain.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        size: 1024,\n        smoothing: 0.8,\n        type: \"fft\",\n        channels: 1\n      });\n    }\n  }]);\n  return Analyser;\n}(ToneAudioNode);","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAgCA,aAAa,QAA8B,kCAAkC;AAE7G,SAASC,oBAAoB,QAAQ,0BAA0B;AAC/D,SAASC,KAAK,QAAQ,kBAAkB;AACxC,SAASC,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,MAAM,EAAEC,WAAW,QAAQ,uBAAuB;AAW3D;;;;;AAKA,WAAaC,QAAS;EAAA;EAAA;EAsCrB;IAAA;IAAA;IACC,0BAAML,oBAAoB,CAACK,QAAQ,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IArCvE,UAAI,GAAW,UAAU;IAKlC;;;IAGQ,gBAAU,GAAmB,EAAE;IAiBvC;;;IAGQ,cAAQ,GAAmB,EAAE;IAUpC,IAAMC,OAAO,GAAGR,oBAAoB,CAACK,QAAQ,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAEzF,MAAKE,KAAK,GAAG,MAAKC,MAAM,GAAG,MAAKC,KAAK,GAAG,IAAIT,IAAI,CAAC;MAAEU,OAAO,EAAE,MAAKA;IAAO,CAAE,CAAC;IAC3E,MAAKC,MAAM,GAAG,IAAIZ,KAAK,CAAC;MACvBW,OAAO,EAAE,MAAKA,OAAO;MACrBE,QAAQ,EAAEN,OAAO,CAACM;KAClB,CAAC;IACF,MAAKL,KAAK,CAACM,OAAO,CAAC,MAAKF,MAAM,CAAC;IAE/BT,WAAW,CAACI,OAAO,CAACM,QAAQ,EAAE,CAAC,CAAC;IAEhC;IACA,KAAK,IAAIE,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGR,OAAO,CAACM,QAAQ,EAAEE,OAAO,EAAE,EAAE;MAC5D,MAAKC,UAAU,CAACD,OAAO,CAAC,GAAG,MAAKJ,OAAO,CAACM,cAAc,EAAE;MACxD,MAAKL,MAAM,CAACE,OAAO,CAAC,MAAKE,UAAU,CAACD,OAAO,CAAC,EAAEA,OAAO,EAAE,CAAC,CAAC;;IAG1D;IACA,MAAKG,IAAI,GAAGX,OAAO,CAACW,IAAI;IACxB,MAAKC,IAAI,GAAGZ,OAAO,CAACY,IAAI;IAAC;EAC1B;EAAC;IAAA;IAAA;IAWD;;;;;;IAMA,oBAAQ;MAAA;MACP,IAAI,CAACH,UAAU,CAACI,OAAO,CAAC,UAACC,QAAQ,EAAEC,KAAK,EAAI;QAC3C,IAAMC,MAAM,GAAG,MAAI,CAACC,QAAQ,CAACF,KAAK,CAAC;QACnC,IAAI,MAAI,CAACG,KAAK,KAAK,KAAK,EAAE;UACzBJ,QAAQ,CAACK,qBAAqB,CAACH,MAAM,CAAC;SACtC,MAAM,IAAI,MAAI,CAACE,KAAK,KAAK,UAAU,EAAE;UACrCJ,QAAQ,CAACM,sBAAsB,CAACJ,MAAM,CAAC;;MAEzC,CAAC,CAAC;MACF,IAAI,IAAI,CAACV,QAAQ,KAAK,CAAC,EAAE;QACxB,OAAO,IAAI,CAACW,QAAQ,CAAC,CAAC,CAAC;OACvB,MAAM;QACN,OAAO,IAAI,CAACA,QAAQ;;IAEtB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAQ;MACP,OAAO,IAAI,CAACR,UAAU,CAAC,CAAC,CAAC,CAACY,iBAAiB;IAC5C,CAAC;IAAA,KACD,aAASV,IAAgB;MAAA;MACxB,IAAI,CAACF,UAAU,CAACI,OAAO,CAAC,UAACC,QAAQ,EAAEC,KAAK,EAAI;QAC3CD,QAAQ,CAACQ,OAAO,GAAGX,IAAI,GAAG,CAAC;QAC3B,MAAI,CAACM,QAAQ,CAACF,KAAK,CAAC,GAAG,IAAIQ,YAAY,CAACZ,IAAI,CAAC;MAC9C,CAAC,CAAC;IACH;IAEA;;;;EAAA;IAAA;IAAA,KAIA,eAAY;MACX,OAAO,IAAI,CAACF,UAAU,CAACe,MAAM;IAC9B;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAQ;MACP,OAAO,IAAI,CAACN,KAAK;IAClB,CAAC;IAAA,KACD,aAASN,IAAkB;MAC1BjB,MAAM,CAACiB,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,KAAK,oCAA6BA,IAAI,EAAG;MAChF,IAAI,CAACM,KAAK,GAAGN,IAAI;IAClB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAa;MACZ,OAAO,IAAI,CAACH,UAAU,CAAC,CAAC,CAAC,CAACgB,qBAAqB;IAChD,CAAC;IAAA,KACD,aAAcC,GAAgB;MAC7B,IAAI,CAACjB,UAAU,CAACI,OAAO,CAAC,WAAC;QAAA,OAAIc,CAAC,CAACF,qBAAqB,GAAGC,GAAG;MAAA,EAAC;IAC5D;IAEA;;;EAAA;IAAA;IAAA,OAGA,mBAAO;MACN;MACA,IAAI,CAACjB,UAAU,CAACI,OAAO,CAAC,WAAC;QAAA,OAAIc,CAAC,CAACC,UAAU,EAAE;MAAA,EAAC;MAC5C,IAAI,CAACvB,MAAM,CAACwB,OAAO,EAAE;MACrB,IAAI,CAAC1B,KAAK,CAAC0B,OAAO,EAAE;MACpB,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAlFD,uBAAkB;MACjB,OAAOC,MAAM,CAACC,MAAM,CAACxC,aAAa,CAACO,WAAW,EAAE,EAAE;QACjDa,IAAI,EAAE,IAAI;QACVqB,SAAS,EAAE,GAAG;QACdpB,IAAI,EAAE,KAAqB;QAC3BN,QAAQ,EAAE;OACV,CAAC;IACH;EAAC;EAAA;AAAA,EArE4Bf,aAA8B","names":["ToneAudioNode","optionsFromArguments","Split","Gain","assert","assertRange","Analyser","getDefaults","arguments","options","input","output","_gain","context","_split","channels","connect","channel","_analysers","createAnalyser","size","type","forEach","analyser","index","buffer","_buffers","_type","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","fftSize","Float32Array","length","smoothingTimeConstant","val","a","disconnect","dispose","Object","assign","smoothing"],"sourceRoot":"","sources":["../../../../Tone/component/analysis/Analyser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}