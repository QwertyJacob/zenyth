{"ast":null,"code":"import _classCallCheck from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/eliapirrello/Documents/GitHub/zenyth/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport \"core-js/modules/es.function.name.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport var TickSource = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(TickSource, _ToneWithContext);\n  var _super = _createSuper(TickSource);\n  function TickSource() {\n    var _this;\n    _classCallCheck(this, TickSource);\n    _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\");\n    // set the initial state\n    _this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    _this.setTicksAtTime(0, 0);\n    return _this;\n  }\n  _createClass(TickSource, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var computedTime = this.toSeconds(time);\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n        if (isDefined(offset)) {\n          this.setTicksAtTime(offset, computedTime);\n        }\n      }\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time);\n      // cancel the previous stop\n      if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n        var event = this._state.get(computedTime);\n        if (event && event.time > 0) {\n          this._tickOffset.cancel(event.time);\n          this._state.cancel(event.time);\n        }\n      }\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"stopped\", computedTime);\n      this.setTicksAtTime(0, computedTime);\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n      }\n      return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      time = this.toSeconds(time);\n      this._state.cancel(time);\n      this._tickOffset.cancel(time);\n      return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var _this2 = this;\n      var computedTime = this.toSeconds(time);\n      var stopEvent = this._state.getLastState(\"stopped\", computedTime);\n      // this event allows forEachBetween to iterate until the current time\n      var tmpEvent = {\n        state: \"paused\",\n        time: computedTime\n      };\n      this._state.add(tmpEvent);\n      // keep track of the previous offset event\n      var lastState = stopEvent;\n      var elapsedTicks = 0;\n      // iterate through all the events since the last stop\n      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time;\n        // if there is an offset event in this period use that\n        var offsetEvent = _this2._tickOffset.get(e.time);\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedTicks = offsetEvent.ticks;\n          periodStartTime = offsetEvent.time;\n        }\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedTicks += _this2.frequency.getTicksAtTime(e.time) - _this2.frequency.getTicksAtTime(periodStartTime);\n        }\n        lastState = e;\n      });\n      // remove the temporary event\n      this._state.remove(tmpEvent);\n      // return the ticks\n      return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function set(t) {\n      this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      var _this3 = this;\n      time = this.toSeconds(time);\n      var stopEvent = this._state.getLastState(\"stopped\", time);\n      // this event allows forEachBetween to iterate until the current time\n      var tmpEvent = {\n        state: \"paused\",\n        time: time\n      };\n      this._state.add(tmpEvent);\n      // keep track of the previous offset event\n      var lastState = stopEvent;\n      var elapsedSeconds = 0;\n      // iterate through all the events since the last stop\n      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time;\n        // if there is an offset event in this period use that\n        var offsetEvent = _this3._tickOffset.get(e.time);\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedSeconds = offsetEvent.seconds;\n          periodStartTime = offsetEvent.time;\n        }\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedSeconds += e.time - periodStartTime;\n        }\n        lastState = e;\n      });\n      // remove the temporary event\n      this._state.remove(tmpEvent);\n      // return the ticks\n      return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      time = this.toSeconds(time);\n      this._tickOffset.cancel(time);\n      this._tickOffset.add({\n        seconds: this.frequency.getDurationOfTicks(ticks, time),\n        ticks: ticks,\n        time: time\n      });\n      return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      time = this.toSeconds(time);\n      return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n      var offset = this._tickOffset.get(before);\n      var event = this._state.get(before);\n      var startTime = Math.max(offset.time, event.time);\n      var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n      return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n  }, {\n    key: \"forEachTickBetween\",\n    value: function forEachTickBetween(startTime, endTime, callback) {\n      var _this4 = this;\n      // only iterate through the sections where it is \"started\"\n      var lastStateEvent = this._state.get(startTime);\n      this._state.forEachBetween(startTime, endTime, function (event) {\n        if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n          _this4.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this4.sampleTime, callback);\n        }\n        lastStateEvent = event;\n      });\n      var error = null;\n      if (lastStateEvent && lastStateEvent.state === \"started\") {\n        var maxStartTime = Math.max(lastStateEvent.time, startTime);\n        // figure out the difference between the frequency ticks and the\n        var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n        var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n        var diff = startTicks - ticksAtStart;\n        var offset = Math.ceil(diff) - diff;\n        // guard against floating point issues\n        offset = EQ(offset, 1) ? 0 : offset;\n        var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n        while (nextTickTime < endTime) {\n          try {\n            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n          } catch (e) {\n            error = e;\n            break;\n          }\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n      if (error) {\n        throw error;\n      }\n      return this;\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSource.prototype), \"dispose\", this).call(this);\n      this._state.dispose();\n      this._tickOffset.dispose();\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign({\n        frequency: 1,\n        units: \"hertz\"\n      }, ToneWithContext.getDefaults());\n    }\n  }]);\n  return TickSource;\n}(ToneWithContext);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","getDefaults","arguments","options","frequency","context","units","value","_state","setStateAtTime","setTicksAtTime","getStateAtTime","now","time","offset","computedTime","toSeconds","getValueAtTime","event","get","_tickOffset","cancel","stopEvent","getLastState","tmpEvent","state","add","lastState","elapsedTicks","forEachBetween","sampleTime","periodStartTime","offsetEvent","e","ticks","getTicksAtTime","remove","t","getSecondsAtTime","s","timeToTicks","elapsedSeconds","seconds","getDurationOfTicks","tick","before","startTime","Math","max","absoluteTicks","getTimeOfTick","endTime","callback","lastStateEvent","forEachTickBetween","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose","Object","assign"],"sourceRoot":"","sources":["../../../../Tone/core/clock/TickSource.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module","externalDependencies":[]}